
# Домашнее задание к занятию "`Базы данных, их типы" - `Ривера Александр Андреевич`



### Задание.СУБД

1.1 
Рекомендую СУБД: Реляционная (SQL)
Примеры: PostgreSQL, Oracle, Microsoft SQL Server

Почему:

Финансовые данные требуют строгой структуры, целостности данных, транзакционной согласованности (ACID).
Необходимы сложные запросы, агрегации, связи между таблицами (проекты, статьи расходов, бюджеты, фактические затраты).
Поддержка внешних ключей, ограничений, триггеров, хранимых процедур — критична.
Подходит для построения OLAP-систем, срезов данных, кубов и последующей интеграции с BI-инструментами (например, Power BI, Tableau).


1.2
Для лендингов: NoSQL (документо-ориентированная) — например, MongoDB, Couchbase
Для CRM: NoSQL (MongoDB) или гибридная SQL (PostgreSQL с JSONB)
Почему:

Лендинги генерируют неструктурированные или полуструктурированные данные (формы, UTM-метки, поведение посетителей).
CRM требует гибкости (разные типы сделок, поля, этапы воронки), быстрой записи и масштабируемости.
NoSQL позволяет быстро добавлять новые поля без миграций, масштабироваться горизонтально.

1.3
Рекомендуемая СУБД: Документо-ориентированная (NoSQL)
Пример: MongoDB, Elasticsearch, или даже wiki-система на базе PostgreSQL

Почему:

Данные носят иерархический, текстовый характер (разделы, подразделы, инструкции).
Частые изменения, добавление новых статей, версий.
Важна простота структуры и удобство поиска.


1.4 
Рекомендуемая СУБД: Графовая (Graph DB)
Примеры: Neo4j, Amazon Neptune

Почему:

Задача — поиск кратчайших путей, оптимизация маршрутов, анализ связей (объект → склад → курьер → время).
Графовые СУБД эффективно работают с связями (edges) и узлами (nodes).
Поддерживают алгоритмы поиска (Dijkstra, A)*, анализ сообществ, рекомендации.


### Задание 2 Транзакции


2.1
Пополнение баланса телефона.
Пользователь инициирует пополнение — вводит номер и сумму в интерфейсе.
Система проверяет данные — валидация номера, суммы, активности номера.
Блокировка средств на платёжной системе — резервирование суммы на карте/кошельке.
Отправка запроса оператору связи — через API оператора (например, по протоколу SOAP/REST).
Оператор подтверждает зачисление — возвращает статус "успешно".
Фиксация транзакции в БД — запись в таблицу transactions (id, phone, amount, status, timestamp) с флагом completed.
Требования:

Все шаги должны быть атомарными — если шаг 5 не удался, шаг 3 откатывается (возврат средств).
Использование двухфазного коммита или сага-паттерна при распределённых транзакциях.


### Задание 3 SQL vs NoSQL

3.1 
Пять преимуществ SQL перед NoSQL
Гарантия целостности данных (ACID) — критично для финансов, бухгалтерии, транзакций.
Строгая схема — предотвращает ошибки ввода, упрощает поддержку и документирование.
Мощные возможности для сложных запросов — JOIN, подзапросы, оконные функции, агрегации.
Поддержка транзакций — безопасное выполнение нескольких операций как одной.
Широкая экосистема BI и отчётности — легко интегрируется с Power BI, Tableau, Excel.


### Задание 4 Кластеры 

4 
Критерий выбора СУБД: характер нагрузки и тип данных
Задача: большое количество вычислений на 1000 машинах → OLAP, аналитика, big data

Критерий выбора:

Тип обработки: OLAP (аналитика) vs OLTP (транзакции)
Объём данных: терабайты/петабайты
Требования к скорости: batch vs real-time
Структура данных: структурированные, полу-, неструктурированные
Рекомендуемая модель: Распределённая колоночная СУБД + фреймворк для вычислений

Решение:

СУБД: Apache ClickHouse, Apache Druid, Google BigQuery, Snowflake
Модель вычислений: MapReduce или DAG (Directed Acyclic Graph) через Apache Spark
Почему:

Горизонтальное масштабирование — легко распределяется на 1000 машин.
Высокая скорость обработки — оптимизированы под сканирование миллионов строк.
Интеграция с Hadoop/Spark — позволяет выполнять сложные вычисления (ML, прогнозирование).
Поддержка SQL — упрощает работу аналитиков.
Модель вычислений: DAG (Spark) > MapReduce

Почему DAG лучше: позволяет кешировать промежуточные результаты, выполнять итеративные алгоритмы (ML), более гибкий контроль потока.
Пример: Spark на кластере из 1000 машин может обрабатывать петабайты данных в памяти, что невозможно в традиционных СУБД.



